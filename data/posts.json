[
	{
		"id": "1_post",
		"title": "10 Interview Questions Every JavaScript Developer Should Know",
		"image": "./img/article-image-1.jpg",
		"description": "Lots of developers manage to skate by without ever truly understanding the Two Pillars of JavaScript, asynchronous programming, and essential principles of application architecture. But if you want to build scalable, high quality applications — if you want to lead teams and mentor new developers — these are essential skills you need to master. If you think this article is just theory, think again. You’re probably using these techniques every day without realizing it. Every major JavaScript application I’ve ever seen makes heavy use of prototypal OO, functional programming, asynchronous JavaScript, modularity, and the other topics addressed in this article. Time to stop skating by and get serious about mastering JavaScript.",
		"article": "I ran an app consulting firm in the early days of SaaS, starting before the term was coined. I have worked on hundreds of projects for both startups and fortune 500 companies. I have a background in C++/Java (and assembly, AutoLisp, Delphi, etc…), and I consulted on dozens of Java and C++ apps (both class-oriented OOP languages). I was once an avid supporter of classical inheritance, and even wrote multi-language Rapid Application Development (RAD) tools for it. I saw up close the many ways in which the class paradigm invited unwary developers down the wrong road, and I saw the extremely costly effects. I’ve seen products abruptly discontinued to stop losses, programmers laid off, and companies brought to their knees by brittle, tangled codebases caused primarily by the improper use of classes and class inheritance. Class in JS is not harmless sugar for prototypal OO. Class is a virus that infects everything it touches. It came to us formally in JavaScript with ES6, and at the same time, React was taking off. Lots of people started using classes for React components (you don’t have to: the new React 0.14 supports pure function components, or try react-stamp). Many are unaware that you can build React components in a class-free style. This has caused confusion and incompatibility between React components and other composable elements in the React ecosystem (components, mixins, and component wrappers). During the days of Backbone dominance (Backbone used its own flavor of classes), I watched a once malleable codebase transform into a brittle mess. I saw code complicated by abstractions necessary to unify the calling API of classes that require `new`, and factories that don’t, forcing the use of dependency injection container that ended up coupling every dependent module tightly to the container API. Those of you with Angular experience will understand what I’m talking about. Angular has four different ways to create services, and features a dependency injection container to abstract them all."
	},
	{
		"id": "2_post",
		"title": "Must See JavaScript Dev Tools that Put Other Dev Tools to Shame",
		"image": "./img/article-image-2.jpg",
		"description": "The tools we use now in JS make fancy IDE autocomplete look like a baby chew toy.",
		"article": "When I got into JavaScript, there was only one browser that mattered: NetScape. It dominated completely until Microsoft started shipping IE with the OS. In those days, the argument that JavaScript’s developer tools were weak was actually true. But it hasn’t been true for a really long time, and today, JavaScript has the best dev tool ecosystem I’ve ever seen for any language. Note that I didn’t say “the best IDE”. If you’re looking for a central IDE that unifies your entire dev tool experience, check out Microsoft’s Visual Studio for C#. Pair it with Unity for a good time. I don’t use it myself, but I have heard from people I trust that it’s pretty solid. I have used C++ and the Unreal Game Engine. The first time I tried that, I realized that the web platform dev tools still had a long way to go. But we’ve come a long way since then, and the tools we use now in JS make fancy IDE autocomplete look like a baby chew toy. In particular, JavaScript’s runtime tooling has no match that I’m aware of in any other language."
	},
	{
		"id": "3_post",
		"title": "Forget the Click Bait. Here’s What the JavaScript Job Market Really Looks Like in 2016.",
		"image": "./img/article-image-3.jpg",
		"description": "Some people seem to think that more JavaScript developers in training has been leading to a more competitive job market. This article sets a few things straight, backed by lots of data — most importantly",
		"article": "A little background. I’m a software developer. For the past several years, I have done a lot of interviewing to hire other software developers. I also train JavaScript developers in the skills they’ll need to get great jobs. I have a deep background building and advising high velocity development teams for a variety of startups and fortune 500 companies. I am also the technical advisor for tech talent agent extraordinaire, JS_Cheerleader (my agent — if you want to write your own ticket, reach out to her). She frequently interacts with the top tech companies in the industry, and keeps me in the loop about what they’re looking for. Between that and feedback from students, I have a really good view of both sides of the JavaScript job market. You Should Learn JavaScript The Mashable article didn’t get it all wrong. The “learn JavaScript” advice is solid. About 1/3rd of all developer jobs require some JavaScript knowledge (source: indeed.com). JavaScript is currently the most popular programming language with the richest OSS module ecosystem, and the only programming language with a really convincing universal deployment story: The “write once, run everywhere” dream that Java aspired to — Java fell short. JavaScript pulled it off. Universal JavaScript is an app that runs on servers, on the web platform, and even in native devices (check out React Native), sharing a bulk of the same app logic (not just libraries) across all target platforms. If you’re not using Universal JavaScript to write your apps, you’re wasting a lot of time and money."
	},
	{
		"id": "4_post",
		"title": "Why Hiring is So Hard in Tech",
		"image": "./img/article-image-4.jpg",
		"description": "An article packed with great advice for people trying to hire JavaScript developers, and JavaScript developers trying to be hired. In Silicon Valley, 45% of tech employees are not from the United States. It costs tens of thousands of dollars more to hire non-US workers, and the process entails months of waiting. So why do we hire so many foreign workers? Because it’s even harder to find qualified talent locally. This article examines some of the reasons for that, and what we can do about it.",
		"article": "Instead of assessing a candidate’s abilities, engineers often pick stock puzzles (puzzle performance has zero correlation with job performance), whiteboard coding demonstrations (nobody codes on a whiteboard on the job), or CS101 algorithm tests (experienced devs forgot the useless crap they learned in CS101 years ago so they could remember all the algorithms and design patterns they actually use in real-life). None of those strategies work. They only make the interviewer feel superior, while the candidate struggles because none of those skills get practiced on the job. If a candidate aces those interviews, beware: They’re either fresh out of school with little job experienced, or they spent their time studying for coding interviews instead of actually coding and learning the real skills that are needed to write real apps. I kid you not, there are books dedicated to acing these useless interviews, and mediocre coders who lack proven skills buy them so they’ll get hired in spite of their lack of visible coding talent."
	},
	{
		"id": "5_post",
		"title": "Common Misconceptions About Inheritance in JavaScript",
		"image": "./img/article-image-5.jpg",
		"description": "Many seasoned JavaScript developers have neglected to learn the basic mechanics of prototypal inheritance: one of the most important innovations in CS history, and one of the Two Pillars of JavaScript. To me, this is like a professional photographer who has yet to learn the exposure triangle — the basic formula for controlling much of the visual style of a photograph. Put simply",
		"article": "Classical and prototypal inheritance are fundamentally and semantically distinct. There are some defining characteristics between classical inheritance and prototypal inheritance. For any of this article to make sense, you must keep these points in mind: In class inheritance, instances inherit from a blueprint (the class), and create sub-class relationships. In other words, you can’t use the class like you would use an instance. You can’t invoke instance methods on a class definition itself. You must first create an instance and then invoke methods on that instance. In prototypal inheritance, instances inherit from other instances. Using delegate prototypes (setting the prototype of one instance to refer to an examplar object), it’s literally Objects Linking to Other Objects, or OLOO, as Kyle Simpson calls it. Using concatenative inheritance, you just copy properties from an exemplar object to a new instance."
	},
	{
		"id": "6_post",
		"title": "5 Questions Every Unit Test Must Answer",
		"image": "./img/article-image-6.jpg",
		"description": "Every developer knows we should write unit tests in order to prevent defects from being deployed to production. What most developers don’t know are the essential ingredients of every unit test. I can’t begin to count the number of times I’ve seen a unit test fail, only to investigate and discover that I have absolutely no idea what feature the developer was trying to test, let alone how it went wrong or why it matters.",
		"article": "What you mean by “component aspect” will vary from test to test, depending on the granularity required to provide adequate coverage of the component under test. In this case, we’re going to test the return type of the `compose()` function to make sure it returns the right kind of thing, as opposed to `undefined` or nothing at all because it throws when you run it. Let’s translate this question into test code. The answer goes into the test description. This step is also where we’ll make our function call and pass the callback function that the test runner will invoke when the tests run"
	},
	{
		"id": "7_post",
		"title": "What is WebAssembly? The Dawn of a New Era",
		"image": "./img/article-image-7.jpg",
		"description": "What is wasm? Why should you care? What will it do for us? This post covers those questions in detail, and points you in the right direction if you want to learn more. Wasm is not final, yet, but there are working game prototypes, and there’s already a lot to learn about why this is an important development for the web platform — and why you may want to brush up on your C++ & lisp skills while we wait for wasm to become a widely implemented recommendation.",
		"article": "On real production projects, I have used Jasmine, Mocha, NodeUnit, Tape, and a bunch of other solutions. I have investigated many other options. For the last few years, I have used and continue to use Tape along with Supertest (for API testing) on all of my personal projects and projects that I lead. What are Unit tests? Unit tests exist to test individual units of software functionality. A unit is a module, component, or function. They’re bits of the program that can work independently of the rest of the program. The presence of unit testing implies that the software is designed in a modular fashion. You may hear once in a while that there are ways to make software “more testable.” If you find that it’s hard to write unit tests for your program without mocking lots of other things, that’s a sign that your program is not modular enough. Revealing tight coupling (the opposite of modularity) is one of the many important roles that unit tests play in software creation. Every module should have unit tests, and every application should be made up of modules. In other words, if you’re not writing unit tests, you should be."
	},
	{
		"id": "8_post",
		"title": "The Single Biggest Mistake Programmers Make Every Day",
		"image": "./img/article-image-8.jpg",
		"description": "A simple tweet leads to some profound learning. This post breaks it down and presents lots of concrete ways to be a more effective developer — and make fewer mistakes in the process.",
		"article": "I made a peculiar language choice for this one. I was sick of working in BASIC and Pascal. I wanted to use C, but I was still saving up for my first Borland Turbo C++ boxed set (they literally came in boxes packed with manuals and install disks). I didn’t even have Turbo Assembler, yet. I was writing in assembly language and “compiling” to an executable with the DOS `debug` command line tool. If that sounds crazy, believe me, it was. I’m betting even those of you who used DOS probably didn’t realize you could use debug to assemble instructions, as well as disassemble (reverse engineer) existing code. Sound cool? I hated it. I couldn’t wait to get my hands on Borland Turbo C++ so I could write code like a human being. Eventually, I got it as a gift. Score! But one of my favorite things about Borland Turbo C++ was that it came bundled with Borland Turbo Assembler. What?! Why would you want to write code in assembly language when you have a great high-level object-oriented language like C++ in your toolbelt?"
	},
	{
		"id": "9_post",
		"title": "How to Build a High Velocity Development Team",
		"image": "./img/article-image-9.jpg",
		"description": "I’ve spent years leading development teams. This post is a brain dump encompassing decades of hard-won experience and wisdom. If you want to build a high velocity development team, this is a must read.",
		"article": "What does “make it work” mean? Since I love immediate feedback, I always start with a few simple unit tests that will alert me immediately when I have a solution that works. During the unit tests, I decide what I mean by “make it work”. What are the minimum requirements that the solution needs to satisfy? The practice assignment was a simple scrum checkin app. I selected this app intentionally because it would allow students to practice some simple functional programming, and avoid `class` in a situation where developers commonly rely on classes and class inheritance: UI code. In agile development, we strive to implement the minimum effective amount of process to enable high velocity development. The scrum meeting is a common element of that minimal process. Its purpose is to allow team members to check in with each other. On each work day, each small team gathers to answer three questions"
	},
	{
		"id": "10_post",
		"title": "Why I Use Tape Instead of Mocha and So Should You",
		"image": "./img/article-image-10.jpg",
		"description": "Software testing is an essential part of application development. Tape simplifies the process dramatically.",
		"article": "On a dev team, every person counts, and it’s up to you to maximize the value of every individual developer. But the odds aren’t on your side. Most tech teams fail because most tech teams don’t understand how to hire and motivate developers. The average organizational value of a single developer at a viral startup unicorn is in the millions of dollars per year*. That doesn’t mean that every developer is worth that. It means the outlier employees at the outlier companies are worth that. Sometimes in the tens of millions*. The best companies in the world understand that value, and treat developers with the respect they deserve. If you want to compete with the top tech companies, you need to find those outliers, and once you make a hire, communicate with each developer as if you’re talking to a $1MM developer. Don’t treat them like cogs in the machine. Treat them like you can’t succeed without their help. Because you can’t. You will have to let some go once in a while, but every time you do, remember that $1MM/year just walked away, and it was you who made the mistake."
	}
]